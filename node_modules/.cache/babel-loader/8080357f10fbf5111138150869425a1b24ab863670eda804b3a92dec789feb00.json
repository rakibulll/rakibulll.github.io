{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CanvasUtils = void 0;\nconst ColorUtils_1 = require(\"./ColorUtils\");\nconst NumberUtils_1 = require(\"./NumberUtils\");\nfunction drawLine(context, begin, end) {\n  context.beginPath();\n  context.moveTo(begin.x, begin.y);\n  context.lineTo(end.x, end.y);\n  context.closePath();\n}\nfunction drawTriangle(context, p1, p2, p3) {\n  context.beginPath();\n  context.moveTo(p1.x, p1.y);\n  context.lineTo(p2.x, p2.y);\n  context.lineTo(p3.x, p3.y);\n  context.closePath();\n}\nclass CanvasUtils {\n  static paintBase(context, dimension, baseColor) {\n    context.save();\n    context.fillStyle = baseColor !== null && baseColor !== void 0 ? baseColor : \"rgba(0,0,0,0)\";\n    context.fillRect(0, 0, dimension.width, dimension.height);\n    context.restore();\n  }\n  static clear(context, dimension) {\n    context.clearRect(0, 0, dimension.width, dimension.height);\n  }\n  static drawLinkLine(context, width, begin, end, maxDistance, canvasSize, warp, backgroundMask, composite, colorLine, opacity, shadow) {\n    let drawn = false;\n    if (NumberUtils_1.NumberUtils.getDistance(begin, end) <= maxDistance) {\n      drawLine(context, begin, end);\n      drawn = true;\n    } else if (warp) {\n      let pi1;\n      let pi2;\n      const endNE = {\n        x: end.x - canvasSize.width,\n        y: end.y\n      };\n      const d1 = NumberUtils_1.NumberUtils.getDistances(begin, endNE);\n      if (d1.distance <= maxDistance) {\n        const yi = begin.y - d1.dy / d1.dx * begin.x;\n        pi1 = {\n          x: 0,\n          y: yi\n        };\n        pi2 = {\n          x: canvasSize.width,\n          y: yi\n        };\n      } else {\n        const endSW = {\n          x: end.x,\n          y: end.y - canvasSize.height\n        };\n        const d2 = NumberUtils_1.NumberUtils.getDistances(begin, endSW);\n        if (d2.distance <= maxDistance) {\n          const yi = begin.y - d2.dy / d2.dx * begin.x;\n          const xi = -yi / (d2.dy / d2.dx);\n          pi1 = {\n            x: xi,\n            y: 0\n          };\n          pi2 = {\n            x: xi,\n            y: canvasSize.height\n          };\n        } else {\n          const endSE = {\n            x: end.x - canvasSize.width,\n            y: end.y - canvasSize.height\n          };\n          const d3 = NumberUtils_1.NumberUtils.getDistances(begin, endSE);\n          if (d3.distance <= maxDistance) {\n            const yi = begin.y - d3.dy / d3.dx * begin.x;\n            const xi = -yi / (d3.dy / d3.dx);\n            pi1 = {\n              x: xi,\n              y: yi\n            };\n            pi2 = {\n              x: pi1.x + canvasSize.width,\n              y: pi1.y + canvasSize.height\n            };\n          }\n        }\n      }\n      if (pi1 && pi2) {\n        drawLine(context, begin, pi1);\n        drawLine(context, end, pi2);\n        drawn = true;\n      }\n    }\n    if (!drawn) {\n      return;\n    }\n    context.lineWidth = width;\n    if (backgroundMask) {\n      context.globalCompositeOperation = composite;\n    }\n    context.strokeStyle = ColorUtils_1.ColorUtils.getStyleFromRgb(colorLine, opacity);\n    if (shadow.enable) {\n      const shadowColor = ColorUtils_1.ColorUtils.colorToRgb(shadow.color);\n      if (shadowColor) {\n        context.shadowBlur = shadow.blur;\n        context.shadowColor = ColorUtils_1.ColorUtils.getStyleFromRgb(shadowColor);\n      }\n    }\n    context.stroke();\n  }\n  static drawLinkTriangle(context, pos1, pos2, pos3, backgroundMask, composite, colorTriangle, opacityTriangle) {\n    drawTriangle(context, pos1, pos2, pos3);\n    if (backgroundMask) {\n      context.globalCompositeOperation = composite;\n    }\n    context.fillStyle = ColorUtils_1.ColorUtils.getStyleFromRgb(colorTriangle, opacityTriangle);\n    context.fill();\n  }\n  static drawConnectLine(context, width, lineStyle, begin, end) {\n    context.save();\n    drawLine(context, begin, end);\n    context.lineWidth = width;\n    context.strokeStyle = lineStyle;\n    context.stroke();\n    context.restore();\n  }\n  static gradient(context, p1, p2, opacity) {\n    const gradStop = Math.floor(p2.getRadius() / p1.getRadius());\n    const color1 = p1.getFillColor();\n    const color2 = p2.getFillColor();\n    if (!color1 || !color2) {\n      return;\n    }\n    const sourcePos = p1.getPosition();\n    const destPos = p2.getPosition();\n    const midRgb = ColorUtils_1.ColorUtils.mix(color1, color2, p1.getRadius(), p2.getRadius());\n    const grad = context.createLinearGradient(sourcePos.x, sourcePos.y, destPos.x, destPos.y);\n    grad.addColorStop(0, ColorUtils_1.ColorUtils.getStyleFromHsl(color1, opacity));\n    grad.addColorStop(gradStop > 1 ? 1 : gradStop, ColorUtils_1.ColorUtils.getStyleFromRgb(midRgb, opacity));\n    grad.addColorStop(1, ColorUtils_1.ColorUtils.getStyleFromHsl(color2, opacity));\n    return grad;\n  }\n  static drawGrabLine(context, width, begin, end, colorLine, opacity) {\n    context.save();\n    drawLine(context, begin, end);\n    context.strokeStyle = ColorUtils_1.ColorUtils.getStyleFromRgb(colorLine, opacity);\n    context.lineWidth = width;\n    context.stroke();\n    context.restore();\n  }\n  static drawLight(container, context, mousePos) {\n    const lightOptions = container.actualOptions.interactivity.modes.light.area;\n    context.beginPath();\n    context.arc(mousePos.x, mousePos.y, lightOptions.radius, 0, 2 * Math.PI);\n    const gradientAmbientLight = context.createRadialGradient(mousePos.x, mousePos.y, 0, mousePos.x, mousePos.y, lightOptions.radius);\n    const gradient = lightOptions.gradient;\n    const gradientRgb = {\n      start: ColorUtils_1.ColorUtils.colorToRgb(gradient.start),\n      stop: ColorUtils_1.ColorUtils.colorToRgb(gradient.stop)\n    };\n    if (!gradientRgb.start || !gradientRgb.stop) {\n      return;\n    }\n    gradientAmbientLight.addColorStop(0, ColorUtils_1.ColorUtils.getStyleFromRgb(gradientRgb.start));\n    gradientAmbientLight.addColorStop(1, ColorUtils_1.ColorUtils.getStyleFromRgb(gradientRgb.stop));\n    context.fillStyle = gradientAmbientLight;\n    context.fill();\n  }\n  static drawParticleShadow(container, context, particle, mousePos) {\n    const pos = particle.getPosition();\n    const shadowOptions = container.actualOptions.interactivity.modes.light.shadow;\n    context.save();\n    const radius = particle.getRadius();\n    const sides = particle.sides;\n    const full = Math.PI * 2 / sides;\n    const angle = -particle.rotate.value + Math.PI / 4;\n    const factor = 1;\n    const dots = [];\n    for (let i = 0; i < sides; i++) {\n      dots.push({\n        x: pos.x + radius * Math.sin(angle + full * i) * factor,\n        y: pos.y + radius * Math.cos(angle + full * i) * factor\n      });\n    }\n    const points = [];\n    const shadowLength = shadowOptions.length;\n    for (const dot of dots) {\n      const dotAngle = Math.atan2(mousePos.y - dot.y, mousePos.x - dot.x);\n      const endX = dot.x + shadowLength * Math.sin(-dotAngle - Math.PI / 2);\n      const endY = dot.y + shadowLength * Math.cos(-dotAngle - Math.PI / 2);\n      points.push({\n        endX: endX,\n        endY: endY,\n        startX: dot.x,\n        startY: dot.y\n      });\n    }\n    const shadowRgb = ColorUtils_1.ColorUtils.colorToRgb(shadowOptions.color);\n    if (!shadowRgb) {\n      return;\n    }\n    const shadowColor = ColorUtils_1.ColorUtils.getStyleFromRgb(shadowRgb);\n    for (let i = points.length - 1; i >= 0; i--) {\n      const n = i == points.length - 1 ? 0 : i + 1;\n      context.beginPath();\n      context.moveTo(points[i].startX, points[i].startY);\n      context.lineTo(points[n].startX, points[n].startY);\n      context.lineTo(points[n].endX, points[n].endY);\n      context.lineTo(points[i].endX, points[i].endY);\n      context.fillStyle = shadowColor;\n      context.fill();\n    }\n    context.restore();\n  }\n  static drawParticle(container, context, particle, delta, fillColorValue, strokeColorValue, backgroundMask, composite, radius, opacity, shadow) {\n    const pos = particle.getPosition();\n    const tiltOptions = particle.options.tilt;\n    const rollOptions = particle.options.roll;\n    context.save();\n    if (tiltOptions.enable || rollOptions.enable) {\n      context.setTransform(rollOptions.enable ? Math.cos(particle.rollAngle) : 1, tiltOptions.enable ? Math.cos(particle.tilt.value) * particle.tilt.cosDirection : 0, tiltOptions.enable ? Math.sin(particle.tilt.value) * particle.tilt.sinDirection : 0, rollOptions.enable ? Math.sin(particle.rollAngle) : 1, pos.x, pos.y);\n    } else {\n      context.translate(pos.x, pos.y);\n    }\n    context.beginPath();\n    const angle = particle.rotate.value + (particle.options.rotate.path ? particle.velocity.angle : 0);\n    if (angle !== 0) {\n      context.rotate(angle);\n    }\n    if (backgroundMask) {\n      context.globalCompositeOperation = composite;\n    }\n    const shadowColor = particle.shadowColor;\n    if (shadow.enable && shadowColor) {\n      context.shadowBlur = shadow.blur;\n      context.shadowColor = ColorUtils_1.ColorUtils.getStyleFromRgb(shadowColor);\n      context.shadowOffsetX = shadow.offset.x;\n      context.shadowOffsetY = shadow.offset.y;\n    }\n    if (fillColorValue) {\n      context.fillStyle = fillColorValue;\n    }\n    const stroke = particle.stroke;\n    context.lineWidth = particle.strokeWidth;\n    if (strokeColorValue) {\n      context.strokeStyle = strokeColorValue;\n    }\n    CanvasUtils.drawShape(container, context, particle, radius, opacity, delta);\n    if (stroke.width > 0) {\n      context.stroke();\n    }\n    if (particle.close) {\n      context.closePath();\n    }\n    if (particle.fill) {\n      context.fill();\n    }\n    context.restore();\n    context.save();\n    if (tiltOptions.enable) {\n      context.setTransform(1, Math.cos(particle.tilt.value) * particle.tilt.cosDirection, Math.sin(particle.tilt.value) * particle.tilt.sinDirection, 1, pos.x, pos.y);\n    } else {\n      context.translate(pos.x, pos.y);\n    }\n    if (angle !== 0) {\n      context.rotate(angle);\n    }\n    if (backgroundMask) {\n      context.globalCompositeOperation = composite;\n    }\n    CanvasUtils.drawShapeAfterEffect(container, context, particle, radius, opacity, delta);\n    context.restore();\n  }\n  static drawShape(container, context, particle, radius, opacity, delta) {\n    if (!particle.shape) {\n      return;\n    }\n    const drawer = container.drawers.get(particle.shape);\n    if (!drawer) {\n      return;\n    }\n    drawer.draw(context, particle, radius, opacity, delta, container.retina.pixelRatio);\n  }\n  static drawShapeAfterEffect(container, context, particle, radius, opacity, delta) {\n    if (!particle.shape) {\n      return;\n    }\n    const drawer = container.drawers.get(particle.shape);\n    if (!(drawer === null || drawer === void 0 ? void 0 : drawer.afterEffect)) {\n      return;\n    }\n    drawer.afterEffect(context, particle, radius, opacity, delta, container.retina.pixelRatio);\n  }\n  static drawPlugin(context, plugin, delta) {\n    if (plugin.draw !== undefined) {\n      context.save();\n      plugin.draw(context, delta);\n      context.restore();\n    }\n  }\n}\nexports.CanvasUtils = CanvasUtils;","map":{"version":3,"names":["Object","defineProperty","exports","value","CanvasUtils","ColorUtils_1","require","NumberUtils_1","drawLine","context","begin","end","beginPath","moveTo","x","y","lineTo","closePath","drawTriangle","p1","p2","p3","paintBase","dimension","baseColor","save","fillStyle","fillRect","width","height","restore","clear","clearRect","drawLinkLine","maxDistance","canvasSize","warp","backgroundMask","composite","colorLine","opacity","shadow","drawn","NumberUtils","getDistance","pi1","pi2","endNE","d1","getDistances","distance","yi","dy","dx","endSW","d2","xi","endSE","d3","lineWidth","globalCompositeOperation","strokeStyle","ColorUtils","getStyleFromRgb","enable","shadowColor","colorToRgb","color","shadowBlur","blur","stroke","drawLinkTriangle","pos1","pos2","pos3","colorTriangle","opacityTriangle","fill","drawConnectLine","lineStyle","gradient","gradStop","Math","floor","getRadius","color1","getFillColor","color2","sourcePos","getPosition","destPos","midRgb","mix","grad","createLinearGradient","addColorStop","getStyleFromHsl","drawGrabLine","drawLight","container","mousePos","lightOptions","actualOptions","interactivity","modes","light","area","arc","radius","PI","gradientAmbientLight","createRadialGradient","gradientRgb","start","stop","drawParticleShadow","particle","pos","shadowOptions","sides","full","angle","rotate","factor","dots","i","push","sin","cos","points","shadowLength","length","dot","dotAngle","atan2","endX","endY","startX","startY","shadowRgb","n","drawParticle","delta","fillColorValue","strokeColorValue","tiltOptions","options","tilt","rollOptions","roll","setTransform","rollAngle","cosDirection","sinDirection","translate","path","velocity","shadowOffsetX","offset","shadowOffsetY","strokeWidth","drawShape","close","drawShapeAfterEffect","shape","drawer","drawers","get","draw","retina","pixelRatio","afterEffect","drawPlugin","plugin","undefined"],"sources":["H:/React Website/node_modules/tsparticles/Utils/CanvasUtils.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CanvasUtils = void 0;\nconst ColorUtils_1 = require(\"./ColorUtils\");\nconst NumberUtils_1 = require(\"./NumberUtils\");\nfunction drawLine(context, begin, end) {\n    context.beginPath();\n    context.moveTo(begin.x, begin.y);\n    context.lineTo(end.x, end.y);\n    context.closePath();\n}\nfunction drawTriangle(context, p1, p2, p3) {\n    context.beginPath();\n    context.moveTo(p1.x, p1.y);\n    context.lineTo(p2.x, p2.y);\n    context.lineTo(p3.x, p3.y);\n    context.closePath();\n}\nclass CanvasUtils {\n    static paintBase(context, dimension, baseColor) {\n        context.save();\n        context.fillStyle = baseColor !== null && baseColor !== void 0 ? baseColor : \"rgba(0,0,0,0)\";\n        context.fillRect(0, 0, dimension.width, dimension.height);\n        context.restore();\n    }\n    static clear(context, dimension) {\n        context.clearRect(0, 0, dimension.width, dimension.height);\n    }\n    static drawLinkLine(context, width, begin, end, maxDistance, canvasSize, warp, backgroundMask, composite, colorLine, opacity, shadow) {\n        let drawn = false;\n        if (NumberUtils_1.NumberUtils.getDistance(begin, end) <= maxDistance) {\n            drawLine(context, begin, end);\n            drawn = true;\n        }\n        else if (warp) {\n            let pi1;\n            let pi2;\n            const endNE = {\n                x: end.x - canvasSize.width,\n                y: end.y,\n            };\n            const d1 = NumberUtils_1.NumberUtils.getDistances(begin, endNE);\n            if (d1.distance <= maxDistance) {\n                const yi = begin.y - (d1.dy / d1.dx) * begin.x;\n                pi1 = { x: 0, y: yi };\n                pi2 = { x: canvasSize.width, y: yi };\n            }\n            else {\n                const endSW = {\n                    x: end.x,\n                    y: end.y - canvasSize.height,\n                };\n                const d2 = NumberUtils_1.NumberUtils.getDistances(begin, endSW);\n                if (d2.distance <= maxDistance) {\n                    const yi = begin.y - (d2.dy / d2.dx) * begin.x;\n                    const xi = -yi / (d2.dy / d2.dx);\n                    pi1 = { x: xi, y: 0 };\n                    pi2 = { x: xi, y: canvasSize.height };\n                }\n                else {\n                    const endSE = {\n                        x: end.x - canvasSize.width,\n                        y: end.y - canvasSize.height,\n                    };\n                    const d3 = NumberUtils_1.NumberUtils.getDistances(begin, endSE);\n                    if (d3.distance <= maxDistance) {\n                        const yi = begin.y - (d3.dy / d3.dx) * begin.x;\n                        const xi = -yi / (d3.dy / d3.dx);\n                        pi1 = { x: xi, y: yi };\n                        pi2 = { x: pi1.x + canvasSize.width, y: pi1.y + canvasSize.height };\n                    }\n                }\n            }\n            if (pi1 && pi2) {\n                drawLine(context, begin, pi1);\n                drawLine(context, end, pi2);\n                drawn = true;\n            }\n        }\n        if (!drawn) {\n            return;\n        }\n        context.lineWidth = width;\n        if (backgroundMask) {\n            context.globalCompositeOperation = composite;\n        }\n        context.strokeStyle = ColorUtils_1.ColorUtils.getStyleFromRgb(colorLine, opacity);\n        if (shadow.enable) {\n            const shadowColor = ColorUtils_1.ColorUtils.colorToRgb(shadow.color);\n            if (shadowColor) {\n                context.shadowBlur = shadow.blur;\n                context.shadowColor = ColorUtils_1.ColorUtils.getStyleFromRgb(shadowColor);\n            }\n        }\n        context.stroke();\n    }\n    static drawLinkTriangle(context, pos1, pos2, pos3, backgroundMask, composite, colorTriangle, opacityTriangle) {\n        drawTriangle(context, pos1, pos2, pos3);\n        if (backgroundMask) {\n            context.globalCompositeOperation = composite;\n        }\n        context.fillStyle = ColorUtils_1.ColorUtils.getStyleFromRgb(colorTriangle, opacityTriangle);\n        context.fill();\n    }\n    static drawConnectLine(context, width, lineStyle, begin, end) {\n        context.save();\n        drawLine(context, begin, end);\n        context.lineWidth = width;\n        context.strokeStyle = lineStyle;\n        context.stroke();\n        context.restore();\n    }\n    static gradient(context, p1, p2, opacity) {\n        const gradStop = Math.floor(p2.getRadius() / p1.getRadius());\n        const color1 = p1.getFillColor();\n        const color2 = p2.getFillColor();\n        if (!color1 || !color2) {\n            return;\n        }\n        const sourcePos = p1.getPosition();\n        const destPos = p2.getPosition();\n        const midRgb = ColorUtils_1.ColorUtils.mix(color1, color2, p1.getRadius(), p2.getRadius());\n        const grad = context.createLinearGradient(sourcePos.x, sourcePos.y, destPos.x, destPos.y);\n        grad.addColorStop(0, ColorUtils_1.ColorUtils.getStyleFromHsl(color1, opacity));\n        grad.addColorStop(gradStop > 1 ? 1 : gradStop, ColorUtils_1.ColorUtils.getStyleFromRgb(midRgb, opacity));\n        grad.addColorStop(1, ColorUtils_1.ColorUtils.getStyleFromHsl(color2, opacity));\n        return grad;\n    }\n    static drawGrabLine(context, width, begin, end, colorLine, opacity) {\n        context.save();\n        drawLine(context, begin, end);\n        context.strokeStyle = ColorUtils_1.ColorUtils.getStyleFromRgb(colorLine, opacity);\n        context.lineWidth = width;\n        context.stroke();\n        context.restore();\n    }\n    static drawLight(container, context, mousePos) {\n        const lightOptions = container.actualOptions.interactivity.modes.light.area;\n        context.beginPath();\n        context.arc(mousePos.x, mousePos.y, lightOptions.radius, 0, 2 * Math.PI);\n        const gradientAmbientLight = context.createRadialGradient(mousePos.x, mousePos.y, 0, mousePos.x, mousePos.y, lightOptions.radius);\n        const gradient = lightOptions.gradient;\n        const gradientRgb = {\n            start: ColorUtils_1.ColorUtils.colorToRgb(gradient.start),\n            stop: ColorUtils_1.ColorUtils.colorToRgb(gradient.stop),\n        };\n        if (!gradientRgb.start || !gradientRgb.stop) {\n            return;\n        }\n        gradientAmbientLight.addColorStop(0, ColorUtils_1.ColorUtils.getStyleFromRgb(gradientRgb.start));\n        gradientAmbientLight.addColorStop(1, ColorUtils_1.ColorUtils.getStyleFromRgb(gradientRgb.stop));\n        context.fillStyle = gradientAmbientLight;\n        context.fill();\n    }\n    static drawParticleShadow(container, context, particle, mousePos) {\n        const pos = particle.getPosition();\n        const shadowOptions = container.actualOptions.interactivity.modes.light.shadow;\n        context.save();\n        const radius = particle.getRadius();\n        const sides = particle.sides;\n        const full = (Math.PI * 2) / sides;\n        const angle = -particle.rotate.value + Math.PI / 4;\n        const factor = 1;\n        const dots = [];\n        for (let i = 0; i < sides; i++) {\n            dots.push({\n                x: pos.x + radius * Math.sin(angle + full * i) * factor,\n                y: pos.y + radius * Math.cos(angle + full * i) * factor,\n            });\n        }\n        const points = [];\n        const shadowLength = shadowOptions.length;\n        for (const dot of dots) {\n            const dotAngle = Math.atan2(mousePos.y - dot.y, mousePos.x - dot.x);\n            const endX = dot.x + shadowLength * Math.sin(-dotAngle - Math.PI / 2);\n            const endY = dot.y + shadowLength * Math.cos(-dotAngle - Math.PI / 2);\n            points.push({\n                endX: endX,\n                endY: endY,\n                startX: dot.x,\n                startY: dot.y,\n            });\n        }\n        const shadowRgb = ColorUtils_1.ColorUtils.colorToRgb(shadowOptions.color);\n        if (!shadowRgb) {\n            return;\n        }\n        const shadowColor = ColorUtils_1.ColorUtils.getStyleFromRgb(shadowRgb);\n        for (let i = points.length - 1; i >= 0; i--) {\n            const n = i == points.length - 1 ? 0 : i + 1;\n            context.beginPath();\n            context.moveTo(points[i].startX, points[i].startY);\n            context.lineTo(points[n].startX, points[n].startY);\n            context.lineTo(points[n].endX, points[n].endY);\n            context.lineTo(points[i].endX, points[i].endY);\n            context.fillStyle = shadowColor;\n            context.fill();\n        }\n        context.restore();\n    }\n    static drawParticle(container, context, particle, delta, fillColorValue, strokeColorValue, backgroundMask, composite, radius, opacity, shadow) {\n        const pos = particle.getPosition();\n        const tiltOptions = particle.options.tilt;\n        const rollOptions = particle.options.roll;\n        context.save();\n        if (tiltOptions.enable || rollOptions.enable) {\n            context.setTransform(rollOptions.enable ? Math.cos(particle.rollAngle) : 1, tiltOptions.enable ? Math.cos(particle.tilt.value) * particle.tilt.cosDirection : 0, tiltOptions.enable ? Math.sin(particle.tilt.value) * particle.tilt.sinDirection : 0, rollOptions.enable ? Math.sin(particle.rollAngle) : 1, pos.x, pos.y);\n        }\n        else {\n            context.translate(pos.x, pos.y);\n        }\n        context.beginPath();\n        const angle = particle.rotate.value + (particle.options.rotate.path ? particle.velocity.angle : 0);\n        if (angle !== 0) {\n            context.rotate(angle);\n        }\n        if (backgroundMask) {\n            context.globalCompositeOperation = composite;\n        }\n        const shadowColor = particle.shadowColor;\n        if (shadow.enable && shadowColor) {\n            context.shadowBlur = shadow.blur;\n            context.shadowColor = ColorUtils_1.ColorUtils.getStyleFromRgb(shadowColor);\n            context.shadowOffsetX = shadow.offset.x;\n            context.shadowOffsetY = shadow.offset.y;\n        }\n        if (fillColorValue) {\n            context.fillStyle = fillColorValue;\n        }\n        const stroke = particle.stroke;\n        context.lineWidth = particle.strokeWidth;\n        if (strokeColorValue) {\n            context.strokeStyle = strokeColorValue;\n        }\n        CanvasUtils.drawShape(container, context, particle, radius, opacity, delta);\n        if (stroke.width > 0) {\n            context.stroke();\n        }\n        if (particle.close) {\n            context.closePath();\n        }\n        if (particle.fill) {\n            context.fill();\n        }\n        context.restore();\n        context.save();\n        if (tiltOptions.enable) {\n            context.setTransform(1, Math.cos(particle.tilt.value) * particle.tilt.cosDirection, Math.sin(particle.tilt.value) * particle.tilt.sinDirection, 1, pos.x, pos.y);\n        }\n        else {\n            context.translate(pos.x, pos.y);\n        }\n        if (angle !== 0) {\n            context.rotate(angle);\n        }\n        if (backgroundMask) {\n            context.globalCompositeOperation = composite;\n        }\n        CanvasUtils.drawShapeAfterEffect(container, context, particle, radius, opacity, delta);\n        context.restore();\n    }\n    static drawShape(container, context, particle, radius, opacity, delta) {\n        if (!particle.shape) {\n            return;\n        }\n        const drawer = container.drawers.get(particle.shape);\n        if (!drawer) {\n            return;\n        }\n        drawer.draw(context, particle, radius, opacity, delta, container.retina.pixelRatio);\n    }\n    static drawShapeAfterEffect(container, context, particle, radius, opacity, delta) {\n        if (!particle.shape) {\n            return;\n        }\n        const drawer = container.drawers.get(particle.shape);\n        if (!(drawer === null || drawer === void 0 ? void 0 : drawer.afterEffect)) {\n            return;\n        }\n        drawer.afterEffect(context, particle, radius, opacity, delta, container.retina.pixelRatio);\n    }\n    static drawPlugin(context, plugin, delta) {\n        if (plugin.draw !== undefined) {\n            context.save();\n            plugin.draw(context, delta);\n            context.restore();\n        }\n    }\n}\nexports.CanvasUtils = CanvasUtils;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}